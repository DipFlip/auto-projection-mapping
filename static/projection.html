<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/x-icon" href="/static/favicon.ico">
  <title>Projection</title>
  <style>
    * { margin: 0; padding: 0; }
    body {
      background: #000;
      overflow: hidden;
      cursor: none;
    }
    canvas { display: block; }
    #status {
      position: fixed;
      top: 20px;
      left: 20px;
      color: #666;
      font-family: monospace;
      font-size: 14px;
      z-index: 100;
    }
  </style>
</head>
<body>
  <div id="status">Waiting for capture...</div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
  <script type="module">
    import * as THREE from 'three';

    let scene, camera, renderer;
    let depthMesh;
    let params = {
      depthScale: 0.5,
      waveSpeed: 0,
      waveAmp: 0,
      hueShift: 0,
      meshRes: 128
    };

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      // Use perspective camera so we can see depth displacement
      camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
      camera.position.set(0, 0, 2.5);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.body.appendChild(renderer.domElement);

      window.addEventListener('resize', onResize);
      animate();

      // Poll for updates from control panel
      pollForUpdates();
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    let frameCount = 0;
    function animate() {
      requestAnimationFrame(animate);

      if (depthMesh) {
        const time = performance.now() * 0.001 * params.waveSpeed;
        depthMesh.material.uniforms.time.value = time;
        depthMesh.material.uniforms.waveAmp.value = params.waveAmp;
        depthMesh.material.uniforms.depthScale.value = params.depthScale;
        depthMesh.material.uniforms.hueShift.value = params.hueShift / 360;
        depthMesh.material.needsUpdate = true;

        frameCount++;
        if (frameCount % 120 === 0) {
          console.log('Projection animate:', { time: time.toFixed(2), waveSpeed: params.waveSpeed, waveAmp: params.waveAmp });
        }
      }

      renderer.render(scene, camera);
    }

    function createDepthMesh(depthImg, originalImg, width, height) {
      if (depthMesh) {
        scene.remove(depthMesh);
        depthMesh.geometry.dispose();
        depthMesh.material.dispose();
      }

      const aspect = width / height;

      // Size plane to fill view
      const planeHeight = 2;
      const planeWidth = planeHeight * aspect;

      const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight, params.meshRes, params.meshRes);

      const loader = new THREE.TextureLoader();
      const depthTexture = loader.load(depthImg);
      const originalTexture = loader.load(originalImg);

      const material = new THREE.ShaderMaterial({
        uniforms: {
          depthMap: { value: depthTexture },
          colorMap: { value: originalTexture },
          depthScale: { value: params.depthScale },
          time: { value: 0 },
          waveAmp: { value: params.waveAmp },
          hueShift: { value: params.hueShift / 360 }
        },
        vertexShader: `
          uniform sampler2D depthMap;
          uniform float depthScale;
          uniform float time;
          uniform float waveAmp;
          varying vec2 vUv;
          varying float vDepth;

          void main() {
            vUv = uv;
            vec4 depth = texture2D(depthMap, uv);
            vDepth = depth.r;
            float displacement = depth.r * depthScale;
            displacement += sin(uv.x * 10.0 + time * 3.0) * sin(uv.y * 10.0 + time * 2.0) * waveAmp;
            vec3 newPosition = position + vec3(0.0, 0.0, displacement);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
          }
        `,
        fragmentShader: `
          uniform sampler2D colorMap;
          uniform float hueShift;
          uniform float time;
          uniform float waveAmp;
          varying vec2 vUv;
          varying float vDepth;

          vec3 rgb2hsv(vec3 c) {
            vec4 K = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);
            vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
            vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
            float d = q.x - min(q.w, q.y);
            float e = 1.0e-10;
            return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
          }

          vec3 hsv2rgb(vec3 c) {
            vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);
            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
          }

          void main() {
            vec4 color = texture2D(colorMap, vUv);
            float colorWave = sin(vUv.x * 20.0 + time * 2.0) * sin(vUv.y * 20.0 + time * 1.5) * waveAmp * 0.5;
            vec3 hsv = rgb2hsv(color.rgb);
            hsv.x = fract(hsv.x + hueShift + colorWave);
            gl_FragColor = vec4(hsv2rgb(hsv), 1.0);
          }
        `,
        side: THREE.DoubleSide
      });

      depthMesh = new THREE.Mesh(geometry, material);
      scene.add(depthMesh);

      document.getElementById('status').style.display = 'none';
    }

    async function pollForUpdates() {
      try {
        const response = await fetch('/api/state');
        if (response.ok) {
          const state = await response.json();

          // Update params
          params.depthScale = state.depthScale;
          params.waveSpeed = state.waveSpeed;
          params.waveAmp = state.waveAmp;
          params.hueShift = state.hueShift;

          // If we have new image data, update the mesh
          if (state.hasCapture && state.captureId !== window.lastCaptureId) {
            console.log('Loading capture:', state.captureId);
            window.lastCaptureId = state.captureId;
            document.getElementById('status').textContent = 'Loading capture...';
            const captureResponse = await fetch('/api/latest-capture');
            if (captureResponse.ok) {
              const data = await captureResponse.json();
              createDepthMesh(data.depth, data.original, data.width, data.height);
              console.log('Mesh created');
            }
          }
        }
      } catch (e) {
        console.log('Poll error:', e);
        document.getElementById('status').textContent = 'Connection error: ' + e.message;
        document.getElementById('status').style.display = 'block';
      }

      // Poll every 100ms
      setTimeout(pollForUpdates, 100);
    }

    // Initial load
    async function initialLoad() {
      try {
        const response = await fetch('/api/latest-capture');
        if (response.ok) {
          const data = await response.json();
          createDepthMesh(data.depth, data.original, data.width, data.height);
          console.log('Initial mesh loaded');
        }
      } catch (e) {
        console.log('No initial capture available');
      }
    }

    init();
    onResize();
    initialLoad();
  </script>
</body>
</html>
