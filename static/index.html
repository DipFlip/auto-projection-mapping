<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/x-icon" href="/static/favicon.ico">
  <title>Projection Mapping</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: #0a0a0a;
      color: #fff;
      overflow: hidden;
    }
    #app {
      display: flex;
      height: 100vh;
    }
    #controls {
      width: 320px;
      padding: 20px;
      background: #151515;
      overflow-y: auto;
      border-right: 1px solid #333;
    }
    #viewport {
      flex: 1;
      position: relative;
    }
    h1 { font-size: 20px; margin-bottom: 20px; }
    h2 { font-size: 12px; color: #666; margin: 20px 0 10px; text-transform: uppercase; letter-spacing: 1px; }
    button {
      width: 100%;
      padding: 14px;
      margin: 6px 0;
      background: #2a5cdb;
      border: none;
      border-radius: 8px;
      color: white;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.2s;
    }
    button:hover { background: #3a6ceb; }
    button:disabled { background: #333; cursor: not-allowed; }
    .preview {
      width: 100%;
      border-radius: 8px;
      margin: 10px 0;
      background: #222;
    }
    #status {
      padding: 12px;
      background: #1a1a1a;
      border-radius: 8px;
      font-size: 13px;
      margin: 10px 0;
      border: 1px solid #333;
    }
    .slider-group {
      margin: 15px 0;
    }
    .slider-group label {
      display: flex;
      justify-content: space-between;
      font-size: 13px;
      margin-bottom: 6px;
      color: #aaa;
    }
    input[type="range"] {
      width: 100%;
      height: 6px;
      background: #333;
      border-radius: 3px;
      outline: none;
      -webkit-appearance: none;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: #2a5cdb;
      border-radius: 50%;
      cursor: pointer;
    }
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    #loading.active { display: flex; }
    .spinner {
      width: 50px;
      height: 50px;
      border: 4px solid #333;
      border-top-color: #2a5cdb;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    .mode-toggle {
      display: flex;
      gap: 8px;
      margin: 10px 0;
    }
    .mode-toggle button {
      flex: 1;
      padding: 10px;
      font-size: 12px;
    }
    .mode-toggle button.active {
      background: #4a7cff;
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="controls">
      <h1>Projection Mapping</h1>

      <div id="status">Ready - Click capture to start</div>

      <h2>Capture</h2>
      <div style="display: flex; gap: 8px;">
        <button id="blankBtn">Blank Screen</button>
        <button id="captureBtn">Capture from Projector</button>
      </div>

      <div style="display: flex; gap: 10px; margin-top: 10px;">
        <img id="originalPreview" class="preview" style="width: 48%; display: none;">
        <img id="depthPreview" class="preview" style="width: 48%; display: none;">
      </div>

      <h2>View Mode</h2>
      <div class="mode-toggle">
        <button id="mode2d" class="active">2D Depth</button>
        <button id="mode3d">3D Mesh</button>
      </div>
      <div style="display: flex; gap: 8px; margin-top: 10px;">
        <button id="openProjector" style="flex: 1; background: #2a8c5c;">Open Projection</button>
        <button id="openCamera" style="flex: 1; background: #8c5c2a;">Open Camera</button>
        <button id="refreshProjector" style="flex: 1; background: #5c5c8c;">Refresh</button>
      </div>

      <h2>Displacement</h2>
      <div class="slider-group">
        <label>Depth Scale <span id="depthScaleVal">0.5</span></label>
        <input type="range" id="depthScale" min="0" max="2" step="0.01" value="0.5">
      </div>

      <div class="slider-group">
        <label>Mesh Resolution <span id="meshResVal">128</span></label>
        <input type="range" id="meshRes" min="32" max="256" step="8" value="128">
      </div>

      <h2>Animation</h2>
      <div class="slider-group">
        <label>Wave Speed <span id="waveSpeedVal">0</span></label>
        <input type="range" id="waveSpeed" min="0" max="2" step="0.1" value="0">
      </div>
      <div class="slider-group">
        <label>Wave Amplitude <span id="waveAmpVal">0</span></label>
        <input type="range" id="waveAmp" min="0" max="0.5" step="0.01" value="0">
      </div>

      <h2>Colors</h2>
      <div class="slider-group">
        <label>Hue Shift <span id="hueShiftVal">0</span></label>
        <input type="range" id="hueShift" min="0" max="360" step="1" value="0">
      </div>

      <h2>Grid Lines</h2>
      <div class="slider-group">
        <label>Grid Opacity <span id="gridOpacityVal">0</span></label>
        <input type="range" id="gridOpacity" min="0" max="1" step="0.05" value="0">
      </div>
      <div class="slider-group">
        <label>Grid Spacing <span id="gridSpacingVal">20</span></label>
        <input type="range" id="gridSpacing" min="5" max="50" step="1" value="20">
      </div>
      <div class="slider-group">
        <label>Grid Line Width <span id="gridWidthVal">1</span></label>
        <input type="range" id="gridWidth" min="0.5" max="5" step="0.5" value="1">
      </div>

      <h2>Edge Detection (Depth)</h2>
      <div class="slider-group">
        <label>Depth Edge Opacity <span id="edgeOpacityVal">0</span></label>
        <input type="range" id="edgeOpacity" min="0" max="1" step="0.05" value="0">
      </div>
      <div class="slider-group">
        <label>Depth Edge Threshold <span id="edgeThresholdVal">0.1</span></label>
        <input type="range" id="edgeThreshold" min="0.01" max="0.5" step="0.01" value="0.1">
      </div>

      <h2>Edge Detection (Photo)</h2>
      <div class="slider-group">
        <label>Photo Edge Opacity <span id="photoEdgeOpacityVal">0</span></label>
        <input type="range" id="photoEdgeOpacity" min="0" max="1" step="0.05" value="0">
      </div>
      <div class="slider-group">
        <label>Photo Edge Threshold <span id="photoEdgeThresholdVal">0.15</span></label>
        <input type="range" id="photoEdgeThreshold" min="0.01" max="0.5" step="0.01" value="0.15">
      </div>

      <h2>Grid Calibration</h2>
      <div id="calibStatus" style="padding: 8px; background: #1a1a1a; border-radius: 6px; margin-bottom: 10px; font-size: 12px;">
        Not calibrated
      </div>
      <div style="display: flex; gap: 8px;">
        <button id="showGridBtn" style="flex: 1; background: #6c5c8c;">Show Grid</button>
        <button id="calibrateGridBtn" style="flex: 1; background: #5c8c6c;">Calibrate Grid</button>
      </div>
      <img id="calibDebug" style="width: 100%; margin-top: 10px; border-radius: 8px; display: none;">

    </div>
    <div id="viewport"></div>
  </div>

  <div id="loading">
    <div class="spinner"></div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    let scene, camera, renderer, controls;
    let depthMesh, planeMesh;
    let depthTexture, originalTexture;
    let currentMode = '2d';
    let depthData = null;

    const params = {
      depthScale: 0.5,
      meshRes: 128,
      waveSpeed: 0,
      waveAmp: 0,
      hueShift: 0,
      gridOpacity: 0,
      gridSpacing: 20,
      gridWidth: 1,
      edgeOpacity: 0,
      edgeThreshold: 0.1,
      photoEdgeOpacity: 0,
      photoEdgeThreshold: 0.15
    };

    function init() {
      const viewport = document.getElementById('viewport');
      const width = viewport.clientWidth;
      const height = viewport.clientHeight;

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0a0a0a);

      camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 100);
      camera.position.set(0, 0, 2);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(width, height);
      renderer.setPixelRatio(window.devicePixelRatio);
      viewport.appendChild(renderer.domElement);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(1, 1, 1);
      scene.add(directionalLight);

      window.addEventListener('resize', onResize);
      animate();
    }

    function onResize() {
      const viewport = document.getElementById('viewport');
      const width = viewport.clientWidth;
      const height = viewport.clientHeight;
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
    }

    let frameCount = 0;
    function animate() {
      requestAnimationFrame(animate);
      controls.update();

      if (depthMesh) {
        const time = performance.now() * 0.001 * params.waveSpeed;
        depthMesh.material.uniforms.time.value = time;
        depthMesh.material.uniforms.waveAmp.value = params.waveAmp;
        depthMesh.material.needsUpdate = true;

        // Debug log every 60 frames
        frameCount++;
        if (frameCount % 60 === 0 && params.waveSpeed > 0) {
          console.log('Animation:', { time: time.toFixed(2), waveAmp: params.waveAmp, waveSpeed: params.waveSpeed });
        }
      }

      renderer.render(scene, camera);
    }

    function createDepthMesh(depthImg, originalImg, width, height) {
      // Remove existing mesh
      if (depthMesh) {
        scene.remove(depthMesh);
        depthMesh.geometry.dispose();
        depthMesh.material.dispose();
      }

      const res = params.meshRes;
      const geometry = new THREE.PlaneGeometry(2, 2 * (height / width), res, res);

      // Load textures
      const loader = new THREE.TextureLoader();
      depthTexture = loader.load(depthImg);
      originalTexture = loader.load(originalImg);

      const material = new THREE.ShaderMaterial({
        uniforms: {
          depthMap: { value: depthTexture },
          colorMap: { value: originalTexture },
          depthScale: { value: params.depthScale },
          time: { value: 0 },
          waveAmp: { value: params.waveAmp },
          hueShift: { value: params.hueShift / 360 },
          gridOpacity: { value: params.gridOpacity },
          gridSpacing: { value: params.gridSpacing },
          gridWidth: { value: params.gridWidth },
          edgeOpacity: { value: params.edgeOpacity },
          edgeThreshold: { value: params.edgeThreshold },
          photoEdgeOpacity: { value: params.photoEdgeOpacity },
          photoEdgeThreshold: { value: params.photoEdgeThreshold },
          resolution: { value: new THREE.Vector2(width, height) }
        },
        vertexShader: `
          uniform sampler2D depthMap;
          uniform float depthScale;
          uniform float time;
          uniform float waveAmp;
          varying vec2 vUv;
          varying float vDepth;

          void main() {
            vUv = uv;
            vec4 depth = texture2D(depthMap, uv);
            vDepth = depth.r;
            float displacement = depth.r * depthScale;
            displacement += sin(uv.x * 10.0 + time * 3.0) * sin(uv.y * 10.0 + time * 2.0) * waveAmp;
            vec3 newPosition = position + vec3(0.0, 0.0, displacement);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
          }
        `,
        fragmentShader: `
          uniform sampler2D colorMap;
          uniform sampler2D depthMap;
          uniform float hueShift;
          uniform float time;
          uniform float waveAmp;
          uniform float gridOpacity;
          uniform float gridSpacing;
          uniform float gridWidth;
          uniform float edgeOpacity;
          uniform float edgeThreshold;
          uniform float photoEdgeOpacity;
          uniform float photoEdgeThreshold;
          uniform vec2 resolution;
          varying vec2 vUv;
          varying float vDepth;

          vec3 rgb2hsv(vec3 c) {
            vec4 K = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);
            vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
            vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
            float d = q.x - min(q.w, q.y);
            float e = 1.0e-10;
            return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
          }

          vec3 hsv2rgb(vec3 c) {
            vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);
            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
          }

          // Calculate grid lines that follow depth surfaces
          float surfaceGrid(vec2 uv, float depth, float spacing, float lineWidth) {
            // Grid in screen space, offset by depth to align with surfaces
            float depthOffset = depth * 50.0;
            vec2 gridUv = uv * resolution / spacing;
            // Offset grid based on depth - creates perspective-aligned grids
            gridUv += vec2(depthOffset * 0.1, depthOffset * 0.1);

            vec2 grid = abs(fract(gridUv - 0.5) - 0.5);
            float lineX = smoothstep(lineWidth / spacing, 0.0, grid.x);
            float lineY = smoothstep(lineWidth / spacing, 0.0, grid.y);
            return max(lineX, lineY);
          }

          // Sobel edge detection on depth
          float detectDepthEdges(vec2 uv, float threshold) {
            vec2 texel = 1.0 / resolution;

            // Sample 3x3 neighborhood
            float tl = texture2D(depthMap, uv + vec2(-texel.x, texel.y)).r;
            float t  = texture2D(depthMap, uv + vec2(0.0, texel.y)).r;
            float tr = texture2D(depthMap, uv + vec2(texel.x, texel.y)).r;
            float l  = texture2D(depthMap, uv + vec2(-texel.x, 0.0)).r;
            float r  = texture2D(depthMap, uv + vec2(texel.x, 0.0)).r;
            float bl = texture2D(depthMap, uv + vec2(-texel.x, -texel.y)).r;
            float b  = texture2D(depthMap, uv + vec2(0.0, -texel.y)).r;
            float br = texture2D(depthMap, uv + vec2(texel.x, -texel.y)).r;

            // Sobel operators
            float gx = -tl - 2.0*l - bl + tr + 2.0*r + br;
            float gy = -tl - 2.0*t - tr + bl + 2.0*b + br;
            float edge = sqrt(gx*gx + gy*gy);

            return smoothstep(threshold * 0.5, threshold, edge);
          }

          // Sobel edge detection on color image (using luminance)
          float detectPhotoEdges(vec2 uv, float threshold) {
            vec2 texel = 1.0 / resolution;

            // Sample 3x3 neighborhood and convert to luminance
            float tl = dot(texture2D(colorMap, uv + vec2(-texel.x, texel.y)).rgb, vec3(0.299, 0.587, 0.114));
            float t  = dot(texture2D(colorMap, uv + vec2(0.0, texel.y)).rgb, vec3(0.299, 0.587, 0.114));
            float tr = dot(texture2D(colorMap, uv + vec2(texel.x, texel.y)).rgb, vec3(0.299, 0.587, 0.114));
            float l  = dot(texture2D(colorMap, uv + vec2(-texel.x, 0.0)).rgb, vec3(0.299, 0.587, 0.114));
            float r  = dot(texture2D(colorMap, uv + vec2(texel.x, 0.0)).rgb, vec3(0.299, 0.587, 0.114));
            float bl = dot(texture2D(colorMap, uv + vec2(-texel.x, -texel.y)).rgb, vec3(0.299, 0.587, 0.114));
            float b  = dot(texture2D(colorMap, uv + vec2(0.0, -texel.y)).rgb, vec3(0.299, 0.587, 0.114));
            float br = dot(texture2D(colorMap, uv + vec2(texel.x, -texel.y)).rgb, vec3(0.299, 0.587, 0.114));

            // Sobel operators
            float gx = -tl - 2.0*l - bl + tr + 2.0*r + br;
            float gy = -tl - 2.0*t - tr + bl + 2.0*b + br;
            float edge = sqrt(gx*gx + gy*gy);

            return smoothstep(threshold * 0.5, threshold, edge);
          }

          void main() {
            vec4 color = texture2D(colorMap, vUv);

            // Add subtle color wave effect
            float colorWave = sin(vUv.x * 20.0 + time * 2.0) * sin(vUv.y * 20.0 + time * 1.5) * waveAmp * 0.5;

            vec3 hsv = rgb2hsv(color.rgb);
            hsv.x = fract(hsv.x + hueShift + colorWave);
            vec3 finalColor = hsv2rgb(hsv);

            // Grid lines - aligned to depth surfaces
            if (gridOpacity > 0.0) {
              float grid = surfaceGrid(vUv, vDepth, gridSpacing, gridWidth);
              vec3 gridColor = vec3(0.0, 1.0, 0.8); // Cyan grid
              finalColor = mix(finalColor, gridColor, grid * gridOpacity);
            }

            // Depth edge detection overlay
            if (edgeOpacity > 0.0) {
              float edge = detectDepthEdges(vUv, edgeThreshold);
              vec3 edgeColor = vec3(1.0, 0.2, 0.5); // Magenta edges
              finalColor = mix(finalColor, edgeColor, edge * edgeOpacity);
            }

            // Photo edge detection overlay
            if (photoEdgeOpacity > 0.0) {
              float edge = detectPhotoEdges(vUv, photoEdgeThreshold);
              vec3 edgeColor = vec3(1.0, 1.0, 0.0); // Yellow edges for photo
              finalColor = mix(finalColor, edgeColor, edge * photoEdgeOpacity);
            }

            gl_FragColor = vec4(finalColor, 1.0);
          }
        `,
        side: THREE.DoubleSide
      });

      depthMesh = new THREE.Mesh(geometry, material);
      scene.add(depthMesh);

      camera.position.set(0, 0, 2);
      controls.reset();
    }

    function setMode(mode) {
      currentMode = mode;
      document.querySelectorAll('.mode-toggle button').forEach(b => b.classList.remove('active'));
      document.getElementById('mode' + mode.charAt(0).toUpperCase() + mode.slice(1)).classList.add('active');

      if (depthMesh) {
        if (mode === '2d') {
          camera.position.set(0, 0, 2);
          controls.enabled = false;
        } else {
          controls.enabled = true;
        }
      }
    }

    async function openOnProjector(action = 'projection') {
      const status = document.getElementById('status');
      const btn = document.getElementById(action === 'camera' ? 'openCamera' : 'openProjector');
      btn.disabled = true;
      status.textContent = action === 'camera' ? 'Opening IP Webcam on projector...' : 'Opening projection on projector...';

      try {
        // Server will determine the correct LAN IP
        const hostIp = null;

        const response = await fetch('/api/open-on-projector', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ hostIp, action })
        });

        const data = await response.json();
        if (data.status === 'ok') {
          status.textContent = data.message;
        } else {
          status.textContent = 'Error: ' + data.message;
        }
      } catch (err) {
        status.textContent = 'Error: ' + err.message;
      } finally {
        btn.disabled = false;
      }
    }

    async function capture() {
      const loading = document.getElementById('loading');
      const status = document.getElementById('status');

      loading.classList.add('active');
      status.textContent = 'Capturing and processing...';

      try {
        const response = await fetch('/api/capture');
        if (!response.ok) throw new Error('Capture failed');

        const data = await response.json();
        depthData = data;

        document.getElementById('originalPreview').src = data.original;
        document.getElementById('originalPreview').style.display = 'block';
        document.getElementById('depthPreview').src = data.depth;
        document.getElementById('depthPreview').style.display = 'block';

        createDepthMesh(data.depth, data.original, data.width, data.height);

        status.textContent = `Captured ${data.width}x${data.height} - Depth map generated`;
      } catch (err) {
        status.textContent = 'Error: ' + err.message;
      } finally {
        loading.classList.remove('active');
      }
    }

    function updateUniforms() {
      if (depthMesh) {
        depthMesh.material.uniforms.depthScale.value = params.depthScale;
        depthMesh.material.uniforms.waveAmp.value = params.waveAmp;
        depthMesh.material.uniforms.hueShift.value = params.hueShift / 360;
        depthMesh.material.uniforms.gridOpacity.value = params.gridOpacity;
        depthMesh.material.uniforms.gridSpacing.value = params.gridSpacing;
        depthMesh.material.uniforms.gridWidth.value = params.gridWidth;
        depthMesh.material.uniforms.edgeOpacity.value = params.edgeOpacity;
        depthMesh.material.uniforms.edgeThreshold.value = params.edgeThreshold;
        depthMesh.material.uniforms.photoEdgeOpacity.value = params.photoEdgeOpacity;
        depthMesh.material.uniforms.photoEdgeThreshold.value = params.photoEdgeThreshold;
      }
    }

    // Sync state to server for projection view
    async function syncState() {
      try {
        await fetch('/api/state', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(params)
        });
      } catch (e) {
        console.log('Sync error:', e);
      }
    }

    // Event listeners
    document.getElementById('captureBtn').addEventListener('click', capture);
    document.getElementById('mode2d').addEventListener('click', () => setMode('2d'));
    document.getElementById('mode3d').addEventListener('click', () => setMode('3d'));
    document.getElementById('openProjector').addEventListener('click', () => openOnProjector('projection'));
    document.getElementById('openCamera').addEventListener('click', () => openOnProjector('camera'));
    document.getElementById('refreshProjector').addEventListener('click', () => openOnProjector('refresh'));

    // Blank screen toggle
    let screenBlanked = false;
    async function toggleBlank() {
      screenBlanked = !screenBlanked;
      const btn = document.getElementById('blankBtn');
      btn.textContent = screenBlanked ? 'Unblank Screen' : 'Blank Screen';
      btn.style.background = screenBlanked ? '#c44' : '';

      await fetch('/api/blank-screen', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ blank: screenBlanked })
      });
    }
    document.getElementById('blankBtn').addEventListener('click', toggleBlank);

    // Grid calibration functions
    let showingGrid = false;

    async function toggleGrid() {
      showingGrid = !showingGrid;
      const btn = document.getElementById('showGridBtn');
      btn.textContent = showingGrid ? 'Hide Grid' : 'Show Grid';
      btn.style.background = showingGrid ? '#8c5c6c' : '#6c5c8c';

      await fetch('/api/show-grid-calibration', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ show: showingGrid, cols: 8, rows: 6, margin: 0.1 })
      });
    }

    async function runGridCalibration() {
      const status = document.getElementById('calibStatus');
      const btn = document.getElementById('calibrateGridBtn');
      const debugImg = document.getElementById('calibDebug');

      btn.disabled = true;
      status.textContent = 'Detecting grid pattern...';
      status.style.color = '#aaa';

      try {
        const response = await fetch('/api/calibrate-grid', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ cols: 8, rows: 6, margin: 0.1 })
        });
        const data = await response.json();

        if (data.status === 'ok') {
          status.textContent = `Calibrated! Crop: L${data.crop.left} R${data.crop.right} T${data.crop.top} B${data.crop.bottom}`;
          status.style.color = '#5c8c5c';
          if (data.debug_image) {
            debugImg.src = data.debug_image;
            debugImg.style.display = 'block';
          }
          showingGrid = false;
          document.getElementById('showGridBtn').textContent = 'Show Grid';
          document.getElementById('showGridBtn').style.background = '#6c5c8c';
        } else {
          status.textContent = 'Error: ' + data.message;
          status.style.color = '#8c5c5c';
        }
      } catch (err) {
        status.textContent = 'Error: ' + err.message;
        status.style.color = '#8c5c5c';
      } finally {
        btn.disabled = false;
      }
    }

    document.getElementById('showGridBtn').addEventListener('click', toggleGrid);
    document.getElementById('calibrateGridBtn').addEventListener('click', runGridCalibration);

    async function checkCalibration() {
      try {
        const response = await fetch('/api/calibration');
        const data = await response.json();
        const status = document.getElementById('calibStatus');
        if (data.calibrated) {
          const crop = data.crop;
          if (crop) {
            status.textContent = `Calibrated: L${crop.left} R${crop.right} T${crop.top} B${crop.bottom}`;
          } else {
            status.textContent = 'Calibrated';
          }
          status.style.color = '#5c8c5c';
        }
      } catch (e) {}
    }

    checkCalibration();

    ['depthScale', 'meshRes', 'waveSpeed', 'waveAmp', 'hueShift', 'gridOpacity', 'gridSpacing', 'gridWidth', 'edgeOpacity', 'edgeThreshold', 'photoEdgeOpacity', 'photoEdgeThreshold'].forEach(id => {
      const el = document.getElementById(id);
      el.addEventListener('input', () => {
        params[id] = parseFloat(el.value);
        document.getElementById(id + 'Val').textContent = el.value;
        updateUniforms();
        syncState();

        if (id === 'meshRes' && depthData) {
          createDepthMesh(depthData.depth, depthData.original, depthData.width, depthData.height);
        }
      });
    });

    // Load default image on startup
    function loadDefault() {
      const defaultData = {
        original: '/static/default_original.jpg',
        depth: '/static/default_depth.png',
        width: 504,
        height: 336
      };
      depthData = defaultData;

      document.getElementById('originalPreview').src = defaultData.original;
      document.getElementById('originalPreview').style.display = 'block';
      document.getElementById('depthPreview').src = defaultData.depth;
      document.getElementById('depthPreview').style.display = 'block';

      createDepthMesh(defaultData.depth, defaultData.original, defaultData.width, defaultData.height);
      document.getElementById('status').textContent = 'Default image loaded - Click capture for live';
    }

    init();
    loadDefault();
  </script>
</body>
</html>
